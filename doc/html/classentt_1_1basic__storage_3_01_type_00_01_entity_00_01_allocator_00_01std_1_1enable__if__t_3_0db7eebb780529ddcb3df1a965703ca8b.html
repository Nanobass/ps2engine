<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ps2engine: entt::basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; component_traits&lt; Type, Entity &gt;::page_size==0u &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ps2engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classentt_1_1basic__storage_3_01_type_00_01_entity_00_01_allocator_00_01std_1_1enable__if__t_3_0db7eebb780529ddcb3df1a965703ca8b.html','','classentt_1_1basic__storage_3_01_type_00_01_entity_00_01_allocator_00_01std_1_1enable__if__t_3_0240003b6b08fe4a4dca6e85370860898'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">entt::basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; component_traits&lt; Type, Entity &gt;::page_size==0u &gt; &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Default constructor.     
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="storage_8hpp_source.html">storage.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for entt::basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; component_traits&lt; Type, Entity &gt;::page_size==0u &gt; &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classentt_1_1basic__storage_3_01_type_00_01_entity_00_01_allocator_00_01std_1_1enable__if__t_3_0db7eebb780529ddcb3df1a965703ca8b.png" usemap="#entt_3A_3Abasic_5Fstorage_3C_20Type_2C_20Entity_2C_20Allocator_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20component_5Ftraits_3C_20Type_2C_20Entity_20_3E_3A_3Apage_5Fsize_3D_3D0u_20_3E_20_3E_map" alt=""/>
  <map id="entt_3A_3Abasic_5Fstorage_3C_20Type_2C_20Entity_2C_20Allocator_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20component_5Ftraits_3C_20Type_2C_20Entity_20_3E_3A_3Apage_5Fsize_3D_3D0u_20_3E_20_3E_map" name="entt_3A_3Abasic_5Fstorage_3C_20Type_2C_20Entity_2C_20Allocator_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20component_5Ftraits_3C_20Type_2C_20Entity_20_3E_3A_3Apage_5Fsize_3D_3D0u_20_3E_20_3E_map">
<area href="classentt_1_1basic__sparse__set.html" alt="entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;" shape="rect" coords="0,0,664,24"/>
<area href="classentt_1_1basic__sparse__set.html" alt="entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;" shape="rect" coords="674,0,1338,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae00607f1ec02d981d3755920008f4b08" id="r_ae00607f1ec02d981d3755920008f4b08"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:ae00607f1ec02d981d3755920008f4b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <br /></td></tr>
<tr class="memitem:a3a5d39878419cd2c516bdd105b608504" id="r_a3a5d39878419cd2c516bdd105b608504"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a5d39878419cd2c516bdd105b608504">base_type</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt;Entity, typename alloc_traits::template rebind_alloc&lt;Entity&gt;&gt;</td></tr>
<tr class="memdesc:a3a5d39878419cd2c516bdd105b608504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type.  <br /></td></tr>
<tr class="memitem:a452a52b0b503ef989532d64cd409d170" id="r_a452a52b0b503ef989532d64cd409d170"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452a52b0b503ef989532d64cd409d170">element_type</a> = Type</td></tr>
<tr class="memdesc:a452a52b0b503ef989532d64cd409d170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type.  <br /></td></tr>
<tr class="memitem:a129141410fa4a0c90ff83bceab7d0266" id="r_a129141410fa4a0c90ff83bceab7d0266"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a129141410fa4a0c90ff83bceab7d0266">value_type</a> = void</td></tr>
<tr class="memdesc:a129141410fa4a0c90ff83bceab7d0266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the objects assigned to entities.  <br /></td></tr>
<tr class="memitem:ae97a505018e245739a3c1a17c48bc57f" id="r_ae97a505018e245739a3c1a17c48bc57f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a> = Entity</td></tr>
<tr class="memdesc:ae97a505018e245739a3c1a17c48bc57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier.  <br /></td></tr>
<tr class="memitem:abb0d8286f1ca301d8a34142e3ca13675" id="r_abb0d8286f1ca301d8a34142e3ca13675"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb0d8286f1ca301d8a34142e3ca13675">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:abb0d8286f1ca301d8a34142e3ca13675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type.  <br /></td></tr>
<tr class="memitem:ad5e9634e59995e6a6debeba735e1cb3c" id="r_ad5e9634e59995e6a6debeba735e1cb3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5e9634e59995e6a6debeba735e1cb3c">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ad5e9634e59995e6a6debeba735e1cb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type.  <br /></td></tr>
<tr class="memitem:a91bed3dea6aa83ced50d6c66e3a5a451" id="r_a91bed3dea6aa83ced50d6c66e3a5a451"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91bed3dea6aa83ced50d6c66e3a5a451">iterable</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">base_type::iterator</a>&gt;&gt;</td></tr>
<tr class="memdesc:a91bed3dea6aa83ced50d6c66e3a5a451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended iterable storage proxy.  <br /></td></tr>
<tr class="memitem:a9ad105c8d5105ab086e364d575f16208" id="r_a9ad105c8d5105ab086e364d575f16208"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad105c8d5105ab086e364d575f16208">const_iterable</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">base_type::const_iterator</a>&gt;&gt;</td></tr>
<tr class="memdesc:a9ad105c8d5105ab086e364d575f16208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant extended iterable storage proxy.  <br /></td></tr>
<tr class="memitem:a986bb0755284684f0e3492120bcbf416" id="r_a986bb0755284684f0e3492120bcbf416"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a986bb0755284684f0e3492120bcbf416">reverse_iterable</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">base_type::reverse_iterator</a>&gt;&gt;</td></tr>
<tr class="memdesc:a986bb0755284684f0e3492120bcbf416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended reverse iterable storage proxy.  <br /></td></tr>
<tr class="memitem:adc7b919c1b1a3d7eb47923a05b2399f3" id="r_adc7b919c1b1a3d7eb47923a05b2399f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7b919c1b1a3d7eb47923a05b2399f3">const_reverse_iterable</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">base_type::const_reverse_iterator</a>&gt;&gt;</td></tr>
<tr class="memdesc:adc7b919c1b1a3d7eb47923a05b2399f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant extended reverse iterable storage proxy.  <br /></td></tr>
<tr class="memitem:ab7a786a114c38b8ee8de18315ec7f7e5" id="r_ab7a786a114c38b8ee8de18315ec7f7e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#ab7a786a114c38b8ee8de18315ec7f7e5">pointer</a></td></tr>
<tr class="memdesc:ab7a786a114c38b8ee8de18315ec7f7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to contained elements.  <br /></td></tr>
<tr class="memitem:a5d8cb6743d7ffa4c83631ec13786b4fe" id="r_a5d8cb6743d7ffa4c83631ec13786b4fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a5d8cb6743d7ffa4c83631ec13786b4fe">const_pointer</a></td></tr>
<tr class="memdesc:a5d8cb6743d7ffa4c83631ec13786b4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant pointer type to contained elements.  <br /></td></tr>
<tr class="memitem:a7de50cda6208b00b58642be70d79da43" id="r_a7de50cda6208b00b58642be70d79da43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a7de50cda6208b00b58642be70d79da43">iterator</a></td></tr>
<tr class="memdesc:a7de50cda6208b00b58642be70d79da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type.  <br /></td></tr>
<tr class="memitem:adfe52c9d60299fe8735adc1ebccd1c22" id="r_adfe52c9d60299fe8735adc1ebccd1c22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a></td></tr>
<tr class="memdesc:adfe52c9d60299fe8735adc1ebccd1c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant random access iterator type.  <br /></td></tr>
<tr class="memitem:aad006022c957075831aee9f1a798b485" id="r_aad006022c957075831aee9f1a798b485"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#aad006022c957075831aee9f1a798b485">reverse_iterator</a></td></tr>
<tr class="memdesc:aad006022c957075831aee9f1a798b485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type.  <br /></td></tr>
<tr class="memitem:a9d153dbdd4f79879d7a8e48ad5aa5484" id="r_a9d153dbdd4f79879d7a8e48ad5aa5484"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a9d153dbdd4f79879d7a8e48ad5aa5484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse iterator type.  <br /></td></tr>
<tr class="inherit_header pub_types_classentt_1_1basic__sparse__set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classentt_1_1basic__sparse__set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Types inherited from <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a></td></tr>
<tr class="memitem:af6faaccfb0c465afb6173b0fb8a37069 inherit pub_types_classentt_1_1basic__sparse__set" id="r_af6faaccfb0c465afb6173b0fb8a37069"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a></td></tr>
<tr class="memdesc:af6faaccfb0c465afb6173b0fb8a37069 inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <br /></td></tr>
<tr class="memitem:ae90adeddf9bab1f9c8b4b1fff95980f0 inherit pub_types_classentt_1_1basic__sparse__set" id="r_ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td></tr>
<tr class="memdesc:ae90adeddf9bab1f9c8b4b1fff95980f0 inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier.  <br /></td></tr>
<tr class="memitem:a14e627591924feaaad4f04d13c4f4b2d inherit pub_types_classentt_1_1basic__sparse__set" id="r_a14e627591924feaaad4f04d13c4f4b2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a></td></tr>
<tr class="memdesc:a14e627591924feaaad4f04d13c4f4b2d inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying version type.  <br /></td></tr>
<tr class="memitem:a2ec9530d8aa9ac94d421b27eb6998edb inherit pub_types_classentt_1_1basic__sparse__set" id="r_a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a></td></tr>
<tr class="memdesc:a2ec9530d8aa9ac94d421b27eb6998edb inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type.  <br /></td></tr>
<tr class="memitem:a4e4e7bb8e12a2d1b35aa91c92bc573c3 inherit pub_types_classentt_1_1basic__sparse__set" id="r_a4e4e7bb8e12a2d1b35aa91c92bc573c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a4e4e7bb8e12a2d1b35aa91c92bc573c3">difference_type</a></td></tr>
<tr class="memdesc:a4e4e7bb8e12a2d1b35aa91c92bc573c3 inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type.  <br /></td></tr>
<tr class="memitem:a8b18963e68d4f003e19389fd342f90cc inherit pub_types_classentt_1_1basic__sparse__set" id="r_a8b18963e68d4f003e19389fd342f90cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8b18963e68d4f003e19389fd342f90cc">pointer</a></td></tr>
<tr class="memdesc:a8b18963e68d4f003e19389fd342f90cc inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to contained entities.  <br /></td></tr>
<tr class="memitem:a6cea231ae7386a12487164d918f632b0 inherit pub_types_classentt_1_1basic__sparse__set" id="r_a6cea231ae7386a12487164d918f632b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a></td></tr>
<tr class="memdesc:a6cea231ae7386a12487164d918f632b0 inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type.  <br /></td></tr>
<tr class="memitem:a3688979d568f2450725d69aa89571f4f inherit pub_types_classentt_1_1basic__sparse__set" id="r_a3688979d568f2450725d69aa89571f4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a></td></tr>
<tr class="memdesc:a3688979d568f2450725d69aa89571f4f inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant random access iterator type.  <br /></td></tr>
<tr class="memitem:afe62c143e816cf5e12078a607966c003 inherit pub_types_classentt_1_1basic__sparse__set" id="r_afe62c143e816cf5e12078a607966c003"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a></td></tr>
<tr class="memdesc:afe62c143e816cf5e12078a607966c003 inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type.  <br /></td></tr>
<tr class="memitem:a27d66fda0fba1587a5f61e9c16f742f7 inherit pub_types_classentt_1_1basic__sparse__set" id="r_a27d66fda0fba1587a5f61e9c16f742f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a27d66fda0fba1587a5f61e9c16f742f7 inherit pub_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse iterator type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a607ddcf3b224f38e658d9be7dbf15da0" id="r_a607ddcf3b224f38e658d9be7dbf15da0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a607ddcf3b224f38e658d9be7dbf15da0">basic_storage</a> ()</td></tr>
<tr class="memdesc:a607ddcf3b224f38e658d9be7dbf15da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="memitem:a7b7b06b2562f3f5cc9d177ca938db341" id="r_a7b7b06b2562f3f5cc9d177ca938db341"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b7b06b2562f3f5cc9d177ca938db341">basic_storage</a> (const <a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a7b7b06b2562f3f5cc9d177ca938db341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator.  <br /></td></tr>
<tr class="memitem:a9afb1279977ec0872920dca913a42fec" id="r_a9afb1279977ec0872920dca913a42fec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9afb1279977ec0872920dca913a42fec">basic_storage</a> (const <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;)=delete</td></tr>
<tr class="memdesc:a9afb1279977ec0872920dca913a42fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor, deleted on purpose.  <br /></td></tr>
<tr class="memitem:a994c6e55039c704227aaa08b504f5424" id="r_a994c6e55039c704227aaa08b504f5424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994c6e55039c704227aaa08b504f5424">basic_storage</a> (<a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a994c6e55039c704227aaa08b504f5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="memitem:a82b0f11b9a2e8f3a93cd5e3441d19cbc" id="r_a82b0f11b9a2e8f3a93cd5e3441d19cbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b0f11b9a2e8f3a93cd5e3441d19cbc">basic_storage</a> (<a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;&amp;other, const <a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a82b0f11b9a2e8f3a93cd5e3441d19cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor.  <br /></td></tr>
<tr class="memitem:a01a5accb1f6fe2c530a0623623d373e3" id="r_a01a5accb1f6fe2c530a0623623d373e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a5accb1f6fe2c530a0623623d373e3">~basic_storage</a> () override=default</td></tr>
<tr class="memdesc:a01a5accb1f6fe2c530a0623623d373e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <br /></td></tr>
<tr class="memitem:a1615c58d643c86da7b901acedc6af5e9" id="r_a1615c58d643c86da7b901acedc6af5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1615c58d643c86da7b901acedc6af5e9">operator=</a> (const <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;)=delete</td></tr>
<tr class="memdesc:a1615c58d643c86da7b901acedc6af5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator, deleted on purpose.  <br /></td></tr>
<tr class="memitem:adc2b36e7668fccf8c46f4ef70db1fc34" id="r_adc2b36e7668fccf8c46f4ef70db1fc34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc2b36e7668fccf8c46f4ef70db1fc34">operator=</a> (<a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:adc2b36e7668fccf8c46f4ef70db1fc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="memitem:a2860b57d969a24f6cf9f84bd8f6fe3a2" id="r_a2860b57d969a24f6cf9f84bd8f6fe3a2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2860b57d969a24f6cf9f84bd8f6fe3a2">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a2860b57d969a24f6cf9f84bd8f6fe3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated allocator.  <br /></td></tr>
<tr class="memitem:ab9cafbd4986dbf0111d3826bc4a33a52" id="r_ab9cafbd4986dbf0111d3826bc4a33a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9cafbd4986dbf0111d3826bc4a33a52">get</a> (const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ab9cafbd4986dbf0111d3826bc4a33a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object assigned to an entity, that is <span class="tt">void</span>.  <br /></td></tr>
<tr class="memitem:a597c72c7242e354b36b23862d4d85c95" id="r_a597c72c7242e354b36b23862d4d85c95"><td class="memItemLeft" align="right" valign="top">std::tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a597c72c7242e354b36b23862d4d85c95">get_as_tuple</a> (const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a597c72c7242e354b36b23862d4d85c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty tuple.  <br /></td></tr>
<tr class="memitem:ae4d9684a7b6ba44ab3a28c63a13282a6" id="r_ae4d9684a7b6ba44ab3a28c63a13282a6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae4d9684a7b6ba44ab3a28c63a13282a6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4d9684a7b6ba44ab3a28c63a13282a6">emplace</a> (const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a> entt, Args &amp;&amp;...)</td></tr>
<tr class="memdesc:ae4d9684a7b6ba44ab3a28c63a13282a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a storage and constructs its object.  <br /></td></tr>
<tr class="memitem:a5a781be8ab6936be9128829159918048" id="r_a5a781be8ab6936be9128829159918048"><td class="memTemplParams" colspan="2">template&lt;typename... Func&gt; </td></tr>
<tr class="memitem:a5a781be8ab6936be9128829159918048 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a781be8ab6936be9128829159918048">patch</a> (const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a> entt, Func &amp;&amp;...func)</td></tr>
<tr class="memdesc:a5a781be8ab6936be9128829159918048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the instance assigned to a given entity in-place.  <br /></td></tr>
<tr class="memitem:a0b7d950f65304e97a723497e7555d584" id="r_a0b7d950f65304e97a723497e7555d584"><td class="memTemplParams" colspan="2">template&lt;typename It, typename... Args&gt; </td></tr>
<tr class="memitem:a0b7d950f65304e97a723497e7555d584 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7d950f65304e97a723497e7555d584">insert</a> (It <a class="el" href="dlheap_8c.html#afcdd80de1d2482a30e49ef0389f36c63">first</a>, It <a class="el" href="dlheap_8c.html#a2474b28851f7dce85a2f54f19c3a2471">last</a>, Args &amp;&amp;...)</td></tr>
<tr class="memdesc:a0b7d950f65304e97a723497e7555d584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns entities to a storage.  <br /></td></tr>
<tr class="memitem:ae8d22ce8b2036a87f02e8235c2fafd1e" id="r_ae8d22ce8b2036a87f02e8235c2fafd1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a91bed3dea6aa83ced50d6c66e3a5a451">iterable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8d22ce8b2036a87f02e8235c2fafd1e">each</a> () noexcept</td></tr>
<tr class="memdesc:ae8d22ce8b2036a87f02e8235c2fafd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object to use to <em>visit</em> a storage.  <br /></td></tr>
<tr class="memitem:ad6177f1e9699daf501afb1dbaa9f00be" id="r_ad6177f1e9699daf501afb1dbaa9f00be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9ad105c8d5105ab086e364d575f16208">const_iterable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6177f1e9699daf501afb1dbaa9f00be">each</a> () const noexcept</td></tr>
<tr class="memdesc:ad6177f1e9699daf501afb1dbaa9f00be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object to use to <em>visit</em> a storage.     <br /></td></tr>
<tr class="memitem:a5bf632552b2eea6c190e87afc92fdbaa" id="r_a5bf632552b2eea6c190e87afc92fdbaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a986bb0755284684f0e3492120bcbf416">reverse_iterable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf632552b2eea6c190e87afc92fdbaa">reach</a> () noexcept</td></tr>
<tr class="memdesc:a5bf632552b2eea6c190e87afc92fdbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterable object to use to <em>visit</em> a storage.  <br /></td></tr>
<tr class="memitem:ad7e7662c420576476cbb0be50d1294be" id="r_ad7e7662c420576476cbb0be50d1294be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adc7b919c1b1a3d7eb47923a05b2399f3">const_reverse_iterable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e7662c420576476cbb0be50d1294be">reach</a> () const noexcept</td></tr>
<tr class="memdesc:ad7e7662c420576476cbb0be50d1294be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterable object to use to <em>visit</em> a storage.     <br /></td></tr>
<tr class="memitem:a630a15d8b585a288e2b37af3af9ebdfe" id="r_a630a15d8b585a288e2b37af3af9ebdfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a630a15d8b585a288e2b37af3af9ebdfe">swap</a> (<a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a630a15d8b585a288e2b37af3af9ebdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents with those of a given storage.  <br /></td></tr>
<tr class="memitem:ad51850043e05582865e5c93fa06421be" id="r_ad51850043e05582865e5c93fa06421be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#ad51850043e05582865e5c93fa06421be">reserve</a> (const <a class="el" href="#abb0d8286f1ca301d8a34142e3ca13675">size_type</a> cap) override</td></tr>
<tr class="memdesc:ad51850043e05582865e5c93fa06421be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of a storage.  <br /></td></tr>
<tr class="memitem:a45d9ea8409804572c0ec705c2bc8c293" id="r_a45d9ea8409804572c0ec705c2bc8c293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abb0d8286f1ca301d8a34142e3ca13675">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a45d9ea8409804572c0ec705c2bc8c293">capacity</a> () const noexcept override</td></tr>
<tr class="memdesc:a45d9ea8409804572c0ec705c2bc8c293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that a storage has currently allocated space for.  <br /></td></tr>
<tr class="memitem:ad569287dadaa314c700f0e904ef71409" id="r_ad569287dadaa314c700f0e904ef71409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#ad569287dadaa314c700f0e904ef71409">shrink_to_fit</a> () override</td></tr>
<tr class="memdesc:ad569287dadaa314c700f0e904ef71409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <br /></td></tr>
<tr class="memitem:a2f4c9502dc518929c71b55f38906d382" id="r_a2f4c9502dc518929c71b55f38906d382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#a5d8cb6743d7ffa4c83631ec13786b4fe">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a2f4c9502dc518929c71b55f38906d382">raw</a> () const noexcept</td></tr>
<tr class="memdesc:a2f4c9502dc518929c71b55f38906d382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the array of objects.  <br /></td></tr>
<tr class="memitem:a9ab3e6177006330420d5590d280a3f33" id="r_a9ab3e6177006330420d5590d280a3f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a9ab3e6177006330420d5590d280a3f33">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a9ab3e6177006330420d5590d280a3f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="memitem:a826c6603fc4f3ed07b2453ff477f1fee" id="r_a826c6603fc4f3ed07b2453ff477f1fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a826c6603fc4f3ed07b2453ff477f1fee">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a826c6603fc4f3ed07b2453ff477f1fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.     <br /></td></tr>
<tr class="memitem:a4429fb49d4f32d6d553150b44951a406" id="r_a4429fb49d4f32d6d553150b44951a406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a4429fb49d4f32d6d553150b44951a406">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a4429fb49d4f32d6d553150b44951a406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="memitem:a28c6c2fb6e1c840a014656568249efc1" id="r_a28c6c2fb6e1c840a014656568249efc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a28c6c2fb6e1c840a014656568249efc1">end</a> () const noexcept</td></tr>
<tr class="memdesc:a28c6c2fb6e1c840a014656568249efc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.     <br /></td></tr>
<tr class="memitem:ada8f048f0df07217eb94bd61f2cec729" id="r_ada8f048f0df07217eb94bd61f2cec729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#ada8f048f0df07217eb94bd61f2cec729">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ada8f048f0df07217eb94bd61f2cec729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <br /></td></tr>
<tr class="memitem:a24ef007aa48f17ac553a93caae35b748" id="r_a24ef007aa48f17ac553a93caae35b748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a24ef007aa48f17ac553a93caae35b748">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a24ef007aa48f17ac553a93caae35b748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.     <br /></td></tr>
<tr class="memitem:accad70b92b1e1667be5ce183928a3d02" id="r_accad70b92b1e1667be5ce183928a3d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#accad70b92b1e1667be5ce183928a3d02">crend</a> () const noexcept</td></tr>
<tr class="memdesc:accad70b92b1e1667be5ce183928a3d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <br /></td></tr>
<tr class="memitem:a8cdc33df100e1ffed0daff4b590a7537" id="r_a8cdc33df100e1ffed0daff4b590a7537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a8cdc33df100e1ffed0daff4b590a7537">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a8cdc33df100e1ffed0daff4b590a7537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.     <br /></td></tr>
<tr class="inherit_header pub_methods_classentt_1_1basic__sparse__set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classentt_1_1basic__sparse__set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a></td></tr>
<tr class="memitem:afc504894fc2c20ea25b7fc2864bd22e3 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_afc504894fc2c20ea25b7fc2864bd22e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afc504894fc2c20ea25b7fc2864bd22e3">basic_sparse_set</a> ()</td></tr>
<tr class="memdesc:afc504894fc2c20ea25b7fc2864bd22e3 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="memitem:ac56f048f614c38f14b19ba9cb27faa94 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ac56f048f614c38f14b19ba9cb27faa94"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56f048f614c38f14b19ba9cb27faa94">~basic_sparse_set</a> ()</td></tr>
<tr class="memdesc:ac56f048f614c38f14b19ba9cb27faa94 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <br /></td></tr>
<tr class="memitem:a71e7865957db2ed2243c77eac979c8ee inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a71e7865957db2ed2243c77eac979c8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a71e7865957db2ed2243c77eac979c8ee">operator=</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;)=delete</td></tr>
<tr class="memdesc:a71e7865957db2ed2243c77eac979c8ee inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator, deleted on purpose.  <br /></td></tr>
<tr class="memitem:a85505b5556cc61ab5557cd311442ad42 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a85505b5556cc61ab5557cd311442ad42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a85505b5556cc61ab5557cd311442ad42">swap</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a85505b5556cc61ab5557cd311442ad42 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents with those of a given sparse set.  <br /></td></tr>
<tr class="memitem:ab292b60dd8782739701906aec8f381ab inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ab292b60dd8782739701906aec8f381ab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab292b60dd8782739701906aec8f381ab">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ab292b60dd8782739701906aec8f381ab inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated allocator.  <br /></td></tr>
<tr class="memitem:a91f80e4333c16c6c3786b041c8a7e8a2 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a91f80e4333c16c6c3786b041c8a7e8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a91f80e4333c16c6c3786b041c8a7e8a2">policy</a> () const noexcept</td></tr>
<tr class="memdesc:a91f80e4333c16c6c3786b041c8a7e8a2 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the deletion policy of a sparse set.  <br /></td></tr>
<tr class="memitem:abc26c3d5467a929c2b88d7ad915c1fa9 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_abc26c3d5467a929c2b88d7ad915c1fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#abc26c3d5467a929c2b88d7ad915c1fa9">free_list</a> () const noexcept</td></tr>
<tr class="memdesc:abc26c3d5467a929c2b88d7ad915c1fa9 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data on the free list whose meaning depends on the mode.  <br /></td></tr>
<tr class="memitem:a7e51c3904b0581866f8791a04435fc5f inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a7e51c3904b0581866f8791a04435fc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a7e51c3904b0581866f8791a04435fc5f">extent</a> () const noexcept</td></tr>
<tr class="memdesc:a7e51c3904b0581866f8791a04435fc5f inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of a sparse set.  <br /></td></tr>
<tr class="memitem:a69ad0662838fd351985a51ee3017fb6c inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a69ad0662838fd351985a51ee3017fb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a69ad0662838fd351985a51ee3017fb6c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a69ad0662838fd351985a51ee3017fb6c inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <br /></td></tr>
<tr class="memitem:ad8936d80c3656449118a7a7a08be6258 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ad8936d80c3656449118a7a7a08be6258"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad8936d80c3656449118a7a7a08be6258">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ad8936d80c3656449118a7a7a08be6258 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <br /></td></tr>
<tr class="memitem:a736ba15d734ea65f18e3c1fd5d748e5e inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a736ba15d734ea65f18e3c1fd5d748e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a736ba15d734ea65f18e3c1fd5d748e5e">contiguous</a> () const noexcept</td></tr>
<tr class="memdesc:a736ba15d734ea65f18e3c1fd5d748e5e inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is fully packed.  <br /></td></tr>
<tr class="memitem:a4c540ff32bca204b1adbd9e4f4a0240b inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a4c540ff32bca204b1adbd9e4f4a0240b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a8b18963e68d4f003e19389fd342f90cc">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a4c540ff32bca204b1adbd9e4f4a0240b">data</a> () const noexcept</td></tr>
<tr class="memdesc:a4c540ff32bca204b1adbd9e4f4a0240b inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <br /></td></tr>
<tr class="memitem:a11b72852c0ae4f7f0dc5f27ba6001f42 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a11b72852c0ae4f7f0dc5f27ba6001f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a11b72852c0ae4f7f0dc5f27ba6001f42">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a11b72852c0ae4f7f0dc5f27ba6001f42 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="memitem:a1934fc85ed01c3528c45ab9a76712fa7 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a1934fc85ed01c3528c45ab9a76712fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1934fc85ed01c3528c45ab9a76712fa7">cbegin</a> () const noexcept</td></tr>
<tr class="memitem:a3187a76bdb963346a715e0ebd833bfd7 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a3187a76bdb963346a715e0ebd833bfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3187a76bdb963346a715e0ebd833bfd7">end</a> () const noexcept</td></tr>
<tr class="memdesc:a3187a76bdb963346a715e0ebd833bfd7 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="memitem:a9f0cc6e746fd49b0c7a0b8e5d8504fef inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9f0cc6e746fd49b0c7a0b8e5d8504fef">cend</a> () const noexcept</td></tr>
<tr class="memitem:aba067d644dcb69d8d11f6d5dc48b9c9b inherit pub_methods_classentt_1_1basic__sparse__set" id="r_aba067d644dcb69d8d11f6d5dc48b9c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aba067d644dcb69d8d11f6d5dc48b9c9b">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aba067d644dcb69d8d11f6d5dc48b9c9b inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <br /></td></tr>
<tr class="memitem:ad57b82c12d92837a14d8904e82eb49a9 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ad57b82c12d92837a14d8904e82eb49a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad57b82c12d92837a14d8904e82eb49a9">crbegin</a> () const noexcept</td></tr>
<tr class="memitem:a408ae201025279196f63ef32cf58da9a inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a408ae201025279196f63ef32cf58da9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a408ae201025279196f63ef32cf58da9a">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a408ae201025279196f63ef32cf58da9a inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <br /></td></tr>
<tr class="memitem:ab28f2f1c7bbf2861f4a3e7602a317b96 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab28f2f1c7bbf2861f4a3e7602a317b96">crend</a> () const noexcept</td></tr>
<tr class="memitem:a8b9656b9f037aede492f66e87e57a6ca inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a8b9656b9f037aede492f66e87e57a6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8b9656b9f037aede492f66e87e57a6ca">find</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a8b9656b9f037aede492f66e87e57a6ca inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entity.  <br /></td></tr>
<tr class="memitem:a97b47cbaea3fc30442fa3e6366766c86 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a97b47cbaea3fc30442fa3e6366766c86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a97b47cbaea3fc30442fa3e6366766c86">contains</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a97b47cbaea3fc30442fa3e6366766c86 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <br /></td></tr>
<tr class="memitem:a96cf0ed9f37ededbd40f6a8c38c1940b inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a96cf0ed9f37ededbd40f6a8c38c1940b">current</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a96cf0ed9f37ededbd40f6a8c38c1940b inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained version for an identifier.  <br /></td></tr>
<tr class="memitem:ad8a8fc74771c26b36fce8234f5e1d1fa inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad8a8fc74771c26b36fce8234f5e1d1fa">index</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ad8a8fc74771c26b36fce8234f5e1d1fa inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <br /></td></tr>
<tr class="memitem:aba848e5d30f1f8fadce544d7bba7296a inherit pub_methods_classentt_1_1basic__sparse__set" id="r_aba848e5d30f1f8fadce544d7bba7296a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aba848e5d30f1f8fadce544d7bba7296a">operator[]</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const noexcept</td></tr>
<tr class="memdesc:aba848e5d30f1f8fadce544d7bba7296a inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location.  <br /></td></tr>
<tr class="memitem:ab3725f4fb86b9bb73f5f397884ff1680 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ab3725f4fb86b9bb73f5f397884ff1680"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab3725f4fb86b9bb73f5f397884ff1680">value</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ab3725f4fb86b9bb73f5f397884ff1680 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element assigned to an entity, if any.  <br /></td></tr>
<tr class="memitem:a8cf01b2a8d20329ec1c1d5d3b5708969 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8cf01b2a8d20329ec1c1d5d3b5708969">push</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt, const void *elem=nullptr)</td></tr>
<tr class="memdesc:a8cf01b2a8d20329ec1c1d5d3b5708969 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <br /></td></tr>
<tr class="memitem:a777ecee811e5fa5567bc462dba476771 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a777ecee811e5fa5567bc462dba476771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a777ecee811e5fa5567bc462dba476771">bump</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:a777ecee811e5fa5567bc462dba476771 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bump the version number of an entity.  <br /></td></tr>
<tr class="memitem:a0a41589e81003ca86b8a6104842680cb inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a0a41589e81003ca86b8a6104842680cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a0a41589e81003ca86b8a6104842680cb">erase</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:a0a41589e81003ca86b8a6104842680cb inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="memitem:af02e5833d5edb2450303bd1c029213b8 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_af02e5833d5edb2450303bd1c029213b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af02e5833d5edb2450303bd1c029213b8">remove</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:af02e5833d5edb2450303bd1c029213b8 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set if it exists.  <br /></td></tr>
<tr class="memitem:af4979ce48546cfcc705c4d23654faef2 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_af4979ce48546cfcc705c4d23654faef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af4979ce48546cfcc705c4d23654faef2">compact</a> ()</td></tr>
<tr class="memdesc:af4979ce48546cfcc705c4d23654faef2 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all tombstones from a sparse set.  <br /></td></tr>
<tr class="memitem:a2b82af720eca37261f3230c654d7fe1f inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a2b82af720eca37261f3230c654d7fe1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2b82af720eca37261f3230c654d7fe1f">swap_elements</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> lhs, const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> rhs)</td></tr>
<tr class="memdesc:a2b82af720eca37261f3230c654d7fe1f inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in a sparse set.  <br /></td></tr>
<tr class="memitem:a43c1c0aa0fa525e12cee0791cd945915 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a43c1c0aa0fa525e12cee0791cd945915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a43c1c0aa0fa525e12cee0791cd945915">sort_n</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> length, Compare compare, Sort algo=Sort{}, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a43c1c0aa0fa525e12cee0791cd945915 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the first count elements according to the given comparison function.  <br /></td></tr>
<tr class="memitem:ae7ceed81905adc0d65291eb9f4072f08 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ae7ceed81905adc0d65291eb9f4072f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae7ceed81905adc0d65291eb9f4072f08">sort</a> (Compare compare, Sort algo=Sort{}, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae7ceed81905adc0d65291eb9f4072f08 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements according to the given comparison function.  <br /></td></tr>
<tr class="memitem:a9e5bf6f1953740446496b834099c3de1 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a9e5bf6f1953740446496b834099c3de1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9e5bf6f1953740446496b834099c3de1">sort_as</a> (It <a class="el" href="dlheap_8c.html#afcdd80de1d2482a30e49ef0389f36c63">first</a>, It <a class="el" href="dlheap_8c.html#a2474b28851f7dce85a2f54f19c3a2471">last</a>)</td></tr>
<tr class="memdesc:a9e5bf6f1953740446496b834099c3de1 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in a range.  <br /></td></tr>
<tr class="memitem:a6560773b887906122d50a413aea1faad inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a6560773b887906122d50a413aea1faad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a6560773b887906122d50a413aea1faad">clear</a> ()</td></tr>
<tr class="memdesc:a6560773b887906122d50a413aea1faad inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a sparse set.  <br /></td></tr>
<tr class="memitem:ae37830b84f2801670927b8ae881d72b7 inherit pub_methods_classentt_1_1basic__sparse__set" id="r_ae37830b84f2801670927b8ae881d72b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae37830b84f2801670927b8ae881d72b7">type</a> () const noexcept</td></tr>
<tr class="memdesc:ae37830b84f2801670927b8ae881d72b7 inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned value type, if any.  <br /></td></tr>
<tr class="memitem:a67b8e3f7cb0144bf663bcd6b9c6e131f inherit pub_methods_classentt_1_1basic__sparse__set" id="r_a67b8e3f7cb0144bf663bcd6b9c6e131f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a67b8e3f7cb0144bf663bcd6b9c6e131f">bind</a> (Type &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:a67b8e3f7cb0144bf663bcd6b9c6e131f inherit pub_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards variables to derived classes, if any.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a55b3e6f1dccfe50350c8dc24a3a0524f" id="r_a55b3e6f1dccfe50350c8dc24a3a0524f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b3e6f1dccfe50350c8dc24a3a0524f">storage_policy</a> {<a class="el" href="structentt_1_1component__traits.html#a1c3296904a082d8ca44d77344ad002ec">traits_type::in_place_delete</a>}</td></tr>
<tr class="memdesc:a55b3e6f1dccfe50350c8dc24a3a0524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage deletion policy.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab2d0f02c4c0a88d6fe42b95e9c2b8226" id="r_ab2d0f02c4c0a88d6fe42b95e9c2b8226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#ab2d0f02c4c0a88d6fe42b95e9c2b8226">pop</a> (underlying_iterator <a class="el" href="dlheap_8c.html#afcdd80de1d2482a30e49ef0389f36c63">first</a>, underlying_iterator <a class="el" href="dlheap_8c.html#a2474b28851f7dce85a2f54f19c3a2471">last</a>) override</td></tr>
<tr class="memdesc:ab2d0f02c4c0a88d6fe42b95e9c2b8226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entities from a storage.  <br /></td></tr>
<tr class="memitem:a343212f5eacd1e124fb85be1a6841b60" id="r_a343212f5eacd1e124fb85be1a6841b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a343212f5eacd1e124fb85be1a6841b60">pop_all</a> () override</td></tr>
<tr class="memdesc:a343212f5eacd1e124fb85be1a6841b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all entities of a storage.  <br /></td></tr>
<tr class="memitem:a96a10490c949af09275a303e7d352f9a" id="r_a96a10490c949af09275a303e7d352f9a"><td class="memItemLeft" align="right" valign="top">underlying_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html#a96a10490c949af09275a303e7d352f9a">try_emplace</a> (const Entity entt, const bool force_back, const void *<a class="el" href="classentt_1_1basic__sparse__set.html#ab3725f4fb86b9bb73f5f397884ff1680">value</a>) override</td></tr>
<tr class="memdesc:a96a10490c949af09275a303e7d352f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a storage.  <br /></td></tr>
<tr class="inherit_header pro_methods_classentt_1_1basic__sparse__set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classentt_1_1basic__sparse__set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a></td></tr>
<tr class="memitem:abde0af92d2d8eade7b5acf5ab02f8038 inherit pro_methods_classentt_1_1basic__sparse__set" id="r_abde0af92d2d8eade7b5acf5ab02f8038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#abde0af92d2d8eade7b5acf5ab02f8038">swap_only</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:abde0af92d2d8eade7b5acf5ab02f8038 inherit pro_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="memitem:a2b95c0acd8af718e712362d1177dbc1e inherit pro_methods_classentt_1_1basic__sparse__set" id="r_a2b95c0acd8af718e712362d1177dbc1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2b95c0acd8af718e712362d1177dbc1e">swap_and_pop</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:a2b95c0acd8af718e712362d1177dbc1e inherit pro_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="memitem:aa45b7ab945ade01c286a35cba5376d7f inherit pro_methods_classentt_1_1basic__sparse__set" id="r_aa45b7ab945ade01c286a35cba5376d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aa45b7ab945ade01c286a35cba5376d7f">in_place_pop</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:aa45b7ab945ade01c286a35cba5376d7f inherit pro_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="memitem:a94662470540e38b7933b23b2ab2249f7 inherit pro_methods_classentt_1_1basic__sparse__set" id="r_a94662470540e38b7933b23b2ab2249f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a94662470540e38b7933b23b2ab2249f7">bind_any</a> (<a class="el" href="namespaceentt.html#a74619fe0ddf5ff5ea9cf98812a3d70ce">any</a>) noexcept</td></tr>
<tr class="memdesc:a94662470540e38b7933b23b2ab2249f7 inherit pro_methods_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards variables to derived classes, if any.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classentt_1_1basic__sparse__set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_classentt_1_1basic__sparse__set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Types inherited from <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a></td></tr>
<tr class="memitem:ac56bb654b47a648d64a754d85c70b40a inherit pro_types_classentt_1_1basic__sparse__set" id="r_ac56bb654b47a648d64a754d85c70b40a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td></tr>
<tr class="memdesc:ac56bb654b47a648d64a754d85c70b40a inherit pro_types_classentt_1_1basic__sparse__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Type, typename Entity, typename Allocator&gt;<br />
class entt::basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; component_traits&lt; Type, Entity &gt;::page_size==0u &gt; &gt;</div><p>Default constructor.    </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00793">793</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ae00607f1ec02d981d3755920008f4b08" name="ae00607f1ec02d981d3755920008f4b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00607f1ec02d981d3755920008f4b08">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::allocator_type = Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00801">801</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a3a5d39878419cd2c516bdd105b608504" name="a3a5d39878419cd2c516bdd105b608504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5d39878419cd2c516bdd105b608504">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::base_type = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt;Entity, typename alloc_traits::template rebind_alloc&lt;Entity&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00803">803</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a9ad105c8d5105ab086e364d575f16208" name="a9ad105c8d5105ab086e364d575f16208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad105c8d5105ab086e364d575f16208">&#9670;&#160;</a></span>const_iterable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::const_iterable = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">base_type::const_iterator</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant extended iterable storage proxy. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00817">817</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="adfe52c9d60299fe8735adc1ebccd1c22" name="adfe52c9d60299fe8735adc1ebccd1c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe52c9d60299fe8735adc1ebccd1c22">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant random access iterator type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00418">418</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a5d8cb6743d7ffa4c83631ec13786b4fe" name="a5d8cb6743d7ffa4c83631ec13786b4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8cb6743d7ffa4c83631ec13786b4fe">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant pointer type to contained elements. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00414">414</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="adc7b919c1b1a3d7eb47923a05b2399f3" name="adc7b919c1b1a3d7eb47923a05b2399f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7b919c1b1a3d7eb47923a05b2399f3">&#9670;&#160;</a></span>const_reverse_iterable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::const_reverse_iterable = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">base_type::const_reverse_iterator</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant extended reverse iterable storage proxy. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00821">821</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a9d153dbdd4f79879d7a8e48ad5aa5484" name="a9d153dbdd4f79879d7a8e48ad5aa5484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d153dbdd4f79879d7a8e48ad5aa5484">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant reverse iterator type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00422">422</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ad5e9634e59995e6a6debeba735e1cb3c" name="ad5e9634e59995e6a6debeba735e1cb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e9634e59995e6a6debeba735e1cb3c">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::difference_type = std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00813">813</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a452a52b0b503ef989532d64cd409d170" name="a452a52b0b503ef989532d64cd409d170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452a52b0b503ef989532d64cd409d170">&#9670;&#160;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::element_type = Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00805">805</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ae97a505018e245739a3c1a17c48bc57f" name="ae97a505018e245739a3c1a17c48bc57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97a505018e245739a3c1a17c48bc57f">&#9670;&#160;</a></span>entity_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::entity_type = Entity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00809">809</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a91bed3dea6aa83ced50d6c66e3a5a451" name="a91bed3dea6aa83ced50d6c66e3a5a451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bed3dea6aa83ced50d6c66e3a5a451">&#9670;&#160;</a></span>iterable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::iterable = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">base_type::iterator</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended iterable storage proxy. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00815">815</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a7de50cda6208b00b58642be70d79da43" name="a7de50cda6208b00b58642be70d79da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de50cda6208b00b58642be70d79da43">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random access iterator type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00416">416</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ab7a786a114c38b8ee8de18315ec7f7e5" name="ab7a786a114c38b8ee8de18315ec7f7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a786a114c38b8ee8de18315ec7f7e5">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer type to contained elements. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00412">412</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a986bb0755284684f0e3492120bcbf416" name="a986bb0755284684f0e3492120bcbf416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986bb0755284684f0e3492120bcbf416">&#9670;&#160;</a></span>reverse_iterable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::reverse_iterable = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::extended_storage_iterator&lt;typename <a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">base_type::reverse_iterator</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended reverse iterable storage proxy. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00819">819</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="aad006022c957075831aee9f1a798b485" name="aad006022c957075831aee9f1a798b485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad006022c957075831aee9f1a798b485">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00420">420</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="abb0d8286f1ca301d8a34142e3ca13675" name="abb0d8286f1ca301d8a34142e3ca13675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0d8286f1ca301d8a34142e3ca13675">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::size_type = std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00811">811</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a129141410fa4a0c90ff83bceab7d0266" name="a129141410fa4a0c90ff83bceab7d0266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129141410fa4a0c90ff83bceab7d0266">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::value_type = void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the objects assigned to entities. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00807">807</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a607ddcf3b224f38e658d9be7dbf15da0" name="a607ddcf3b224f38e658d9be7dbf15da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607ddcf3b224f38e658d9be7dbf15da0">&#9670;&#160;</a></span>basic_storage() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::basic_storage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00826">826</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a7b7b06b2562f3f5cc9d177ca938db341" name="a7b7b06b2562f3f5cc9d177ca938db341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7b06b2562f3f5cc9d177ca938db341">&#9670;&#160;</a></span>basic_storage() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::basic_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00833">833</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a9afb1279977ec0872920dca913a42fec" name="a9afb1279977ec0872920dca913a42fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afb1279977ec0872920dca913a42fec">&#9670;&#160;</a></span>basic_storage() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::basic_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor, deleted on purpose. </p>

</div>
</div>
<a id="a994c6e55039c704227aaa08b504f5424" name="a994c6e55039c704227aaa08b504f5424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994c6e55039c704227aaa08b504f5424">&#9670;&#160;</a></span>basic_storage() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::basic_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82b0f11b9a2e8f3a93cd5e3441d19cbc" name="a82b0f11b9a2e8f3a93cd5e3441d19cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b0f11b9a2e8f3a93cd5e3441d19cbc">&#9670;&#160;</a></span>basic_storage() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::basic_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00850">850</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a01a5accb1f6fe2c530a0623623d373e3" name="a01a5accb1f6fe2c530a0623623d373e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a5accb1f6fe2c530a0623623d373e3">&#9670;&#160;</a></span>~basic_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::~<a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a826c6603fc4f3ed07b2453ff477f1fee" name="a826c6603fc4f3ed07b2453ff477f1fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826c6603fc4f3ed07b2453ff477f1fee">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.    </p>
<p>If the storage is empty, the returned iterator will be equal to <span class="tt"><a class="el" href="classentt_1_1basic__storage.html#a28c6c2fb6e1c840a014656568249efc1">end()</a></span>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the internal array.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00569">569</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a45d9ea8409804572c0ec705c2bc8c293" name="a45d9ea8409804572c0ec705c2bc8c293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d9ea8409804572c0ec705c2bc8c293">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abb0d8286f1ca301d8a34142e3ca13675">size_type</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that a storage has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the storage. </dd></dl>

<p>Reimplemented from <a class="el" href="classentt_1_1basic__sparse__set.html#a17b25baaceb061cd93da56f1ec24ee98">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00533">533</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a9ab3e6177006330420d5590d280a3f33" name="a9ab3e6177006330420d5590d280a3f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab3e6177006330420d5590d280a3f33">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>If the storage is empty, the returned iterator will be equal to <span class="tt"><a class="el" href="classentt_1_1basic__storage.html#a28c6c2fb6e1c840a014656568249efc1">end()</a></span>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the internal array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00563">563</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a4429fb49d4f32d6d553150b44951a406" name="a4429fb49d4f32d6d553150b44951a406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4429fb49d4f32d6d553150b44951a406">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the internal array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00584">584</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ada8f048f0df07217eb94bd61f2cec729" name="ada8f048f0df07217eb94bd61f2cec729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8f048f0df07217eb94bd61f2cec729">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p>If the storage is empty, the returned iterator will be equal to <span class="tt"><a class="el" href="classentt_1_1basic__storage.html#a8cdc33df100e1ffed0daff4b590a7537">rend()</a></span>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the reversed internal array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00605">605</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="accad70b92b1e1667be5ce183928a3d02" name="accad70b92b1e1667be5ce183928a3d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accad70b92b1e1667be5ce183928a3d02">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the reversed internal array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00624">624</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ad6177f1e9699daf501afb1dbaa9f00be" name="ad6177f1e9699daf501afb1dbaa9f00be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6177f1e9699daf501afb1dbaa9f00be">&#9670;&#160;</a></span>each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9ad105c8d5105ab086e364d575f16208">const_iterable</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::each </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterable object to use to <em>visit</em> a storage.    </p>
<p>The iterable object returns a tuple that contains the current entity.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterable object to use to <em>visit</em> the storage.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00960">960</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ae8d22ce8b2036a87f02e8235c2fafd1e" name="ae8d22ce8b2036a87f02e8235c2fafd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d22ce8b2036a87f02e8235c2fafd1e">&#9670;&#160;</a></span>each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a91bed3dea6aa83ced50d6c66e3a5a451">iterable</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::each </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterable object to use to <em>visit</em> a storage. </p>
<p>The iterable object returns a tuple that contains the current entity.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterable object to use to <em>visit</em> the storage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00955">955</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ae4d9684a7b6ba44ab3a28c63a13282a6" name="ae4d9684a7b6ba44ab3a28c63a13282a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d9684a7b6ba44ab3a28c63a13282a6">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a storage and constructs its object. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to use an entity that already belongs to the storage results in undefined behavior.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00917">917</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a28c6c2fb6e1c840a014656568249efc1" name="a28c6c2fb6e1c840a014656568249efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c6c2fb6e1c840a014656568249efc1">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#adfe52c9d60299fe8735adc1ebccd1c22">const_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.    </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the internal array.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00589">589</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ab9cafbd4986dbf0111d3826bc4a33a52" name="ab9cafbd4986dbf0111d3826bc4a33a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cafbd4986dbf0111d3826bc4a33a52">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object assigned to an entity, that is <span class="tt">void</span>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to use an entity that doesn't belong to the storage results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00891">891</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a2860b57d969a24f6cf9f84bd8f6fe3a2" name="a2860b57d969a24f6cf9f84bd8f6fe3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2860b57d969a24f6cf9f84bd8f6fe3a2">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae00607f1ec02d981d3755920008f4b08">allocator_type</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00873">873</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a597c72c7242e354b36b23862d4d85c95" name="a597c72c7242e354b36b23862d4d85c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597c72c7242e354b36b23862d4d85c95">&#9670;&#160;</a></span>get_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::get_as_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an empty tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an empty tuple. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00900">900</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a0b7d950f65304e97a723497e7555d584" name="a0b7d950f65304e97a723497e7555d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7d950f65304e97a723497e7555d584">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<div class="memtemplate">
template&lt;typename It, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns entities to a storage. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of optional arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00942">942</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="adc2b36e7668fccf8c46f4ef70db1fc34" name="adc2b36e7668fccf8c46f4ef70db1fc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2b36e7668fccf8c46f4ef70db1fc34">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp; <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This storage. </dd></dl>

</div>
</div>
<a id="a1615c58d643c86da7b901acedc6af5e9" name="a1615c58d643c86da7b901acedc6af5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1615c58d643c86da7b901acedc6af5e9">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a> &amp; <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator, deleted on purpose. </p>
<dl class="section return"><dt>Returns</dt><dd>This storage. </dd></dl>

</div>
</div>
<a id="a5a781be8ab6936be9128829159918048" name="a5a781be8ab6936be9128829159918048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a781be8ab6936be9128829159918048">&#9670;&#160;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<div class="memtemplate">
template&lt;typename... Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae97a505018e245739a3c1a17c48bc57f">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the instance assigned to a given entity in-place. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of the function objects to invoke. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">func</td><td>Valid function objects. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00928">928</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ab2d0f02c4c0a88d6fe42b95e9c2b8226" name="ab2d0f02c4c0a88d6fe42b95e9c2b8226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d0f02c4c0a88d6fe42b95e9c2b8226">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">underlying_iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">underlying_iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entities from a storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classentt_1_1basic__sparse__set.html#a8f66cbcaa360286d296dcb7a33c7e1ce">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00338">338</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a343212f5eacd1e124fb85be1a6841b60" name="a343212f5eacd1e124fb85be1a6841b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343212f5eacd1e124fb85be1a6841b60">&#9670;&#160;</a></span>pop_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::pop_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all entities of a storage. </p>

<p>Reimplemented from <a class="el" href="classentt_1_1basic__sparse__set.html#a1e8e00e8bfa75311482f2fa071e244e6">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00357">357</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a2f4c9502dc518929c71b55f38906d382" name="a2f4c9502dc518929c71b55f38906d382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4c9502dc518929c71b55f38906d382">&#9670;&#160;</a></span>raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#a5d8cb6743d7ffa4c83631ec13786b4fe">const_pointer</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::raw </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the array of objects. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of objects. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00547">547</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a24ef007aa48f17ac553a93caae35b748" name="a24ef007aa48f17ac553a93caae35b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef007aa48f17ac553a93caae35b748">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.    </p>
<p>If the storage is empty, the returned iterator will be equal to <span class="tt"><a class="el" href="classentt_1_1basic__storage.html#a8cdc33df100e1ffed0daff4b590a7537">rend()</a></span>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the reversed internal array.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00610">610</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ad7e7662c420576476cbb0be50d1294be" name="ad7e7662c420576476cbb0be50d1294be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e7662c420576476cbb0be50d1294be">&#9670;&#160;</a></span>reach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adc7b919c1b1a3d7eb47923a05b2399f3">const_reverse_iterable</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::reach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterable object to use to <em>visit</em> a storage.    </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae8d22ce8b2036a87f02e8235c2fafd1e" title="Returns an iterable object to use to visit a storage.">each</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterable object to use to <em>visit</em> the storage.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00976">976</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a5bf632552b2eea6c190e87afc92fdbaa" name="a5bf632552b2eea6c190e87afc92fdbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf632552b2eea6c190e87afc92fdbaa">&#9670;&#160;</a></span>reach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a986bb0755284684f0e3492120bcbf416">reverse_iterable</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::reach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterable object to use to <em>visit</em> a storage. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae8d22ce8b2036a87f02e8235c2fafd1e" title="Returns an iterable object to use to visit a storage.">each</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterable object to use to <em>visit</em> the storage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00971">971</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a8cdc33df100e1ffed0daff4b590a7537" name="a8cdc33df100e1ffed0daff4b590a7537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdc33df100e1ffed0daff4b590a7537">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html#a9d153dbdd4f79879d7a8e48ad5aa5484">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end.    </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the reversed internal array.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00629">629</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ad51850043e05582865e5c93fa06421be" name="ad51850043e05582865e5c93fa06421be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51850043e05582865e5c93fa06421be">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#abb0d8286f1ca301d8a34142e3ca13675">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of a storage. </p>
<p>If the new capacity is greater than the current capacity, new storage is allocated, otherwise the method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classentt_1_1basic__sparse__set.html#a58d49df52ee3133a1347dc01131a4f1a">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00521">521</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ad569287dadaa314c700f0e904ef71409" name="ad569287dadaa314c700f0e904ef71409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad569287dadaa314c700f0e904ef71409">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>

<p>Reimplemented from <a class="el" href="classentt_1_1basic__sparse__set.html#a7e10cc6ddc7ef9c733aabdec849c5b79">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00538">538</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a630a15d8b585a288e2b37af3af9ebdfe" name="a630a15d8b585a288e2b37af3af9ebdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630a15d8b585a288e2b37af3af9ebdfe">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents with those of a given storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Storage to exchange the content with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00499">499</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a96a10490c949af09275a303e7d352f9a" name="a96a10490c949af09275a303e7d352f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a10490c949af09275a303e7d352f9a">&#9670;&#160;</a></span>try_emplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">underlying_iterator <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, typename &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>entt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>force_back</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">value</td><td>Optional opaque value. </td></tr>
    <tr><td class="paramname">force_back</td><td>Force back insertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element. </dd></dl>

<p>Reimplemented from <a class="el" href="classentt_1_1basic__sparse__set.html#a1c62d9615acde55f57fcca92e44c747c">entt::basic_sparse_set&lt; Entity, std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; Entity &gt; &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00380">380</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a55b3e6f1dccfe50350c8dc24a3a0524f" name="a55b3e6f1dccfe50350c8dc24a3a0524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b3e6f1dccfe50350c8dc24a3a0524f">&#9670;&#160;</a></span>storage_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Entity, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> <a class="el" href="classentt_1_1basic__storage.html">entt::basic_storage</a>&lt; Type, Entity, Allocator, std::enable_if_t&lt; <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt; Type, Entity &gt;::page_size==0u &gt; &gt;::storage_policy {<a class="el" href="structentt_1_1component__traits.html#a1c3296904a082d8ca44d77344ad002ec">traits_type::in_place_delete</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage deletion policy. </p>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00823">823</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>runtime/ee/include/entt/entity/<a class="el" href="storage_8hpp_source.html">storage.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceentt.html">entt</a></li><li class="navelem"><a href="classentt_1_1basic__storage_3_01_type_00_01_entity_00_01_allocator_00_01std_1_1enable__if__t_3_0db7eebb780529ddcb3df1a965703ca8b.html">basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; component_traits&lt; Type, Entity &gt;::page_size==0u &gt; &gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
